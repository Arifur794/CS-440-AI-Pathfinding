package gui.controller;

import gui.model.Cell;
import gui.model.Grid;
import heuristics.DistanceHeuristic;
import javafx.fxml.FXML;
import javafx.geometry.Insets;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import searches.AStar;
import searches.Node;
import searches.UCS;
import searches.WAStar;

public class GridController {
	@FXML 
	private GridPane gridPane;
	private Grid grid;
	private CellDisplayController cellDisplay;
	private Rectangle[][] displayRect;
	final double BUTTON_PADDING = 2;
	final int ROWS = 120; 
	final int COLS = 160;
	final int WIDTH = 1400;
	final int HEIGHT = 780;
	final int CELL_SIZE = 10;
	
	public GridController() {
		this.grid = new Grid(COLS, ROWS);
		this.displayRect = new Rectangle[ROWS][COLS];
	}
	
	@FXML
	private void initialize() {
		initGridGui(gridPane);
	}
	
	public void setCellDisplayController(CellDisplayController cdc) {
		this.cellDisplay = cdc;
	}
	
	public void initGridGui(GridPane gridPane) {
		gridPane.setPadding(new Insets(BUTTON_PADDING));
	    gridPane.setHgap(BUTTON_PADDING);
	    gridPane.setVgap(BUTTON_PADDING);

	    this.gridPane = gridPane;
		grid.createGrid();
		colorGrid();
	}
	
	private void addClick(Rectangle rect, int c, int r) {
		rect.setOnMouseClicked(e -> {
			Cell cell = grid.getCell(c, r);
			this.cellDisplay.showInfo(cell);
    	});
	}
	
	public Grid getGrid() {
		return this.grid;
	}
	
	public void colorGrid() {
		//System.out.println("Here");
		gridPane.getChildren().clear();
		
		Rectangle rect;
	    Cell cell;
	    Color color;
	    
	    for (int r = 1; r <= ROWS; r++) {
	        for (int c = 1; c <= COLS; c++) {

	            	cell = grid.getCell(c, r);
	            	switch(cell.celltype) {
		            	case UNBLOCKED:
		            		color = Color.WHITE;
		            		break;
		            	case HARD:
		            		color = Color.GREEN;
		            		break;
		            	case HIGHWAY_UNBLOCKED:
		            		color = Color.BLUE;
		            		break;
		            	case HIGHWAY_HARD:
		            		color = Color.PURPLE;
		            		break;
		            	case BLOCKED:
		            		color = Color.BLACK;
		            		break;
		            	case START_POINT_UNBLOCKED:
		            	case START_POINT_HARD:
		            		color = Color.ORANGE;
		            		break;
		            	case END_POINT_UNBLOCKED:
		            	case END_POINT_HARD:
		            		color = Color.RED;
		            		break;
		            	default:
		            		color = Color.WHITE;
	            	}
	            	rect = new Rectangle(CELL_SIZE, CELL_SIZE, color);
	            	addClick(rect, c, r);
	            	gridPane.add(rect, c, r);           
	        }
	    }
	}
	
	public void changeGrid(Grid grid) {
		this.grid = grid;
		colorGrid();
	}
	
	public void runAStar() {
		Node start = new Node(grid.getCell(grid.startCell[0] + 1, grid.startCell[1] + 1));
		Node end = new Node(grid.getCell(grid.endCell[0] + 1, grid.endCell[1] + 1));
		DistanceHeuristic heuristic = new DistanceHeuristic(grid);
		AStar pathFinder = new AStar(start, end, grid, heuristic);
		Node[] path = pathFinder.run();
		System.out.println(pathFinder.calculateCost());
		
		for(Node n : path) {
			this.displayRect[n.y][n.x].setFill(Color.YELLOW);
		}
	}
	
	public void runWAStar() {
		Node start = new Node(grid.getCell(grid.startCell[0] + 1, grid.startCell[1] + 1));
		Node end = new Node(grid.getCell(grid.endCell[0] + 1, grid.endCell[1] + 1));
		DistanceHeuristic heuristic = new DistanceHeuristic(grid);
		WAStar pathFinder = new WAStar(start, end, grid, heuristic, 2);
		Node[] path = pathFinder.run();
		System.out.println(pathFinder.calculateCost());
		
		for(Node n : path) {
			this.displayRect[n.y][n.x].setFill(Color.YELLOW);
		}
	}

	public void runUCS() {
		Node start = new Node(grid.getCell(grid.startCell[1] + 1, grid.startCell[0] + 1));
		Node end = new Node(grid.getCell(grid.endCell[1] + 1, grid.endCell[0] + 1));
		UCS pathFinder = new UCS(start, end, grid);
		Node[] path = pathFinder.run();
		System.out.println(pathFinder.calculateCost());
		
		for(Node n : path) {
			if (n.x != grid.endCell[1] && n.y != endCell[0]) {
				this.displayRect[n.y][n.x].setFill(Color.YELLOW);
			}
			
		}
	}
}
