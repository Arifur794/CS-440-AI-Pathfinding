package heuristics;

import gui.model.Grid;
import searches.Node;

public class DistanceHeuristic {
	private int bx, by, sx, sy;
	private float startToGoalDist;
	
	
	@SuppressWarnings("unused")
	private Grid g;
	public DistanceHeuristic(Grid g) {
		this.g = g;
		bx = g.endCell[1];
		by = g.endCell[0];
		sx = g.startCell[1];
		sy = g.endCell[0];
		
		//the diagonal line distance from start to goal from Pythagorean theorem.
		startToGoalDist = (float) Math.sqrt( ((sx - bx)*(sx- bx)) + ((sy-by)*(sy-by)) );
	}
	
	public float getH(Node a) {
		//get the diagonal line distance from current place to goal and get 1/4th of it since in a best case scenario we always travel with an actual cost of .25.
		//Divide that by the startToGoalDistance on the diagonal.
		return ( 0.25f * (float) Math.sqrt( ((a.x - bx)*(a.x- bx)) + ((a.y-by)*(a.y-by)) ) ) / startToGoalDist;
		
		//same as above but get half of it instead. Works in more cases but not all.
		//return ( 0.50f * (float) Math.sqrt( ((a.x - bx)*(a.x- bx)) + ((a.y-by)*(a.y-by)) ) ) / startToGoalDist; 
		
		//still looking for a number to get this formula working but it doesn't seem to. Maybe something else is needed.
		//return (0.1f * (float) Math.sqrt( ((a.x - bx)*(a.x- bx)) + ((a.y-by)*(a.y-by)) ) ) / startToGoalDist;
		
		//works on the maps were reducing it didn't but doesn't work on the maps where reducing the path from currNode did.
		//return ((float) Math.sqrt( ((a.x - bx)*(a.x- bx)) + ((a.y-by)*(a.y-by)) ) ) / startToGoalDist;
	}
}
